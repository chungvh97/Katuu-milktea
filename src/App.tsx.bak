import React, { useState, useRef, useEffect, useMemo, useCallback } from 'react';
import type { Order, Product, Topping, Size, HistoricOrder, Category } from './types';
import { PRODUCTS, TOPPINGS, SIZES, SUGAR_LEVELS, ICE_LEVELS, CATEGORIES } from './constants';
import * as menuService from './services/menuService';
import { AuthProvider } from './contexts/AuthContext';
import { AuditProvider } from './contexts/AuditContext';
import { OrderSessionProvider } from './contexts/OrderSessionContext';
import ProtectedRoute from './components/ProtectedRoute';
import Header from './components/Header';
import ProductSelection from './components/ProductSelection';
import CustomizationOptions from './components/CustomizationOptions';
import OrderSummary from './components/OrderSummary';
import OrderHistory from './components/OrderHistory';
import AdminPanel from './components/AdminPanel';
import Dashboard from './components/Dashboard';
import PendingOrdersPanel from './components/PendingOrdersPanel';
import MergedOrdersHistory from './components/MergedOrdersHistory';
import OrderSummaryReport from './components/OrderSummaryReport';
import { ArrowUpIcon } from './assets/icons';

const initialOrderState: Order = {
  product: null,
  toppings: [],
  size: SIZES[0],
  sugar: SUGAR_LEVELS[0],
  ice: ICE_LEVELS[0],
  customerName: '',
};

const App: React.FC = () => {
  const [order, setOrder] = useState<Order>(initialOrderState);
  const [isResetting, setIsResetting] = useState(false);
  const [orderHistory, setOrderHistory] = useState<HistoricOrder[]>([]);
  const [view, setView] = useState<'ordering' | 'history' | 'admin' | 'dashboard' | 'pending' | 'merged' | 'summary'>('ordering');
  const [isScrollButtonVisible, setIsScrollButtonVisible] = useState(false);
  const [isHeaderScrolled, setIsHeaderScrolled] = useState(false);
  const [isLoadingHistory, setIsLoadingHistory] = useState(true);
  const [isLoadingProducts, setIsLoadingProducts] = useState(true);
  const [isReordering, setIsReordering] = useState(false);
  
  // Admin data states
  const [products, setProducts] = useState<Product[]>(PRODUCTS);
  const [toppings, setToppings] = useState<Topping[]>(TOPPINGS);
  const [sizes, setSizes] = useState<Size[]>(SIZES);
  const [categories, setCategories] = useState<Category[]>(CATEGORIES);

  // State for filters
  const [productCategory, setProductCategory] = useState('all');
  const [historySearchTerm, setHistorySearchTerm] = useState('');
  const [historyCategory, setHistoryCategory] = useState('all');

  const customizationRef = useRef<HTMLDivElement>(null);
  const [postLoginMessage, setPostLoginMessage] = React.useState<string | null>(null);
  const postLoginTimers = useRef<{ nav?: number; clear?: number }>({});

  // Load admin data from Supabase or localStorage on mount
  useEffect(() => {
    const loadMenuData = async () => {
      try {
        setIsLoadingProducts(true);

        // Load from Supabase (with fallback to constants)
        const [supaProducts, supaToppings, supaSizes, supaCategories] = await Promise.all([
          menuService.fetchProducts(),
          menuService.fetchToppings(),
          menuService.fetchSizes(),
          menuService.fetchCategories()
        ]);

        setProducts(supaProducts);
        setToppings(supaToppings);
        setSizes(supaSizes);
        setCategories(supaCategories);

        console.log('âœ… Menu data loaded:', {
          products: supaProducts.length,
          toppings: supaToppings.length,
          sizes: supaSizes.length,
          categories: supaCategories.length
        });
      } catch (error) {
        console.error('Failed to load menu data:', error);
        // Fallback already handled by service
      } finally {
        setIsLoadingProducts(false);
      }
    };

    loadMenuData();

    // Also try to load from localStorage for admin-modified data
    try {
      const storedProducts = localStorage.getItem('adminProducts');
      const storedToppings = localStorage.getItem('adminToppings');
      const storedSizes = localStorage.getItem('adminSizes');
      const storedCategories = localStorage.getItem('adminCategories');

      if (storedProducts) setProducts(JSON.parse(storedProducts));
      if (storedToppings) setToppings(JSON.parse(storedToppings));
      if (storedSizes) setSizes(JSON.parse(storedSizes));
      if (storedCategories) setCategories(JSON.parse(storedCategories));
    } catch (error) {
      console.error("Failed to load admin data from localStorage", error);
    }
  }, []);

  // Save admin data to localStorage when changed
  const handleUpdateProducts = useCallback((newProducts: Product[]) => {
    setProducts(newProducts);
    localStorage.setItem('adminProducts', JSON.stringify(newProducts));
  }, []);

  const handleUpdateToppings = useCallback((newToppings: Topping[]) => {
    setToppings(newToppings);
    localStorage.setItem('adminToppings', JSON.stringify(newToppings));
  }, []);

  const handleUpdateSizes = useCallback((newSizes: Size[]) => {
    setSizes(newSizes);
    localStorage.setItem('adminSizes', JSON.stringify(newSizes));
  }, []);

  const handleUpdateCategories = useCallback((newCategories: Category[]) => {
    setCategories(newCategories);
    localStorage.setItem('adminCategories', JSON.stringify(newCategories));
  }, []);

  useEffect(() => {
    // Simulate fetching products to show loader
    const timer = setTimeout(() => {
        setIsLoadingProducts(false);
    }, 750); // 750ms delay for visual effect

    return () => clearTimeout(timer);
  }, []);

  useEffect(() => {
    // Simulate fetching data to show loader
    const timer = setTimeout(() => {
        try {
            const storedHistory = localStorage.getItem('bobaBlissOrderHistory');
            const clearedAt = localStorage.getItem('orderHistoryClearedAt');

            console.log('ðŸ” Loading order history...');
            console.log('  storedHistory:', storedHistory);
            console.log('  clearedAt:', clearedAt);

            // Check if history is null or corrupted - clear localStorage
            if (!storedHistory || storedHistory === 'null' || storedHistory === 'undefined') {
                console.log('ðŸ—‘ï¸ No valid history, clearing localStorage');
                localStorage.removeItem('bobaBlissOrderHistory');
                localStorage.removeItem('orderHistoryClearedAt');
                setOrderHistory([]);
                return;
            }

            // Check if history is empty array string
            if (storedHistory === '[]') {
                console.log('âœ… History is empty array, clearing localStorage');
                localStorage.removeItem('bobaBlissOrderHistory');
                localStorage.removeItem('orderHistoryClearedAt');
                setOrderHistory([]);
                return;
            }

            // Parse history data
            const historyData = JSON.parse(storedHistory) as HistoricOrder[];

            console.log('  historyData length:', historyData.length);

            // If parsed data is empty array, clear localStorage
            if (historyData.length === 0) {
                console.log('ðŸ—‘ï¸ Parsed history is empty, clearing localStorage');
                localStorage.removeItem('bobaBlissOrderHistory');
                localStorage.removeItem('orderHistoryClearedAt');
                setOrderHistory([]);
                return;
            }

            // Check if history was cleared by staff
            if (clearedAt) {
                const clearedTimestamp = parseInt(clearedAt, 10);
                const newestOrderTimestamp = Math.max(...historyData.map(o => new Date(o.date).getTime()));

                console.log('  clearedTimestamp:', clearedTimestamp, new Date(clearedTimestamp));
                console.log('  newestOrderTimestamp:', newestOrderTimestamp, new Date(newestOrderTimestamp));

                // If cleared after newest order, don't load old data
                if (clearedTimestamp > newestOrderTimestamp) {
                    console.log('âœ… Order history was cleared by staff, clearing all localStorage');
                    localStorage.removeItem('bobaBlissOrderHistory');
                    localStorage.removeItem('orderHistoryClearedAt');
                    setOrderHistory([]);
                    return;
                } else {
                    console.log('âš ï¸ Cleared timestamp is older than newest order, loading data');
                }
            }

            console.log('ðŸ“ Loading history data:', historyData.length, 'orders');
            setOrderHistory(historyData);
        } catch (error) {
            console.error("Failed to load order history from localStorage", error);
            // On error, clear everything
            localStorage.removeItem('bobaBlissOrderHistory');
            localStorage.removeItem('orderHistoryClearedAt');
            setOrderHistory([]);
        } finally {
            setIsLoadingHistory(false);
        }
    }, 500); // 500ms delay to showcase the loader

    return () => clearTimeout(timer);
  }, []);

  // Listen for localStorage changes (when staff merges orders)
  useEffect(() => {
    const handleStorageChange = (e: StorageEvent) => {
      if (e.key === 'bobaBlissOrderHistory') {
        if (e.newValue === null || e.newValue === '[]') {
          // History was cleared - remove localStorage completely
          console.log('ðŸ“¢ Storage event: bobaBlissOrderHistory cleared, removing localStorage');
          localStorage.removeItem('bobaBlissOrderHistory');
          localStorage.removeItem('orderHistoryClearedAt');
          setOrderHistory([]);
        } else {
          try {
            const parsed = JSON.parse(e.newValue);
            if (Array.isArray(parsed) && parsed.length === 0) {
              // Empty array - remove localStorage
              console.log('ðŸ“¢ Storage event: empty array, removing localStorage');
              localStorage.removeItem('bobaBlissOrderHistory');
              localStorage.removeItem('orderHistoryClearedAt');
              setOrderHistory([]);
            } else {
              setOrderHistory(parsed);
            }
          } catch (error) {
            console.error("Failed to parse order history", error);
            // On error, clear everything
            localStorage.removeItem('bobaBlissOrderHistory');
            localStorage.removeItem('orderHistoryClearedAt');
            setOrderHistory([]);
          }
        }
      }

      // Listen for trigger clear event
      if (e.key === '_triggerClear') {
        console.log('ðŸ“¢ Received _triggerClear signal, removing all localStorage');
        localStorage.removeItem('bobaBlissOrderHistory');
        localStorage.removeItem('orderHistoryClearedAt');
        setOrderHistory([]);
      }

      // Listen for cleared flag update
      if (e.key === 'orderHistoryClearedAt' && e.newValue) {
        console.log('ðŸ“¢ Received orderHistoryClearedAt signal, removing all localStorage');
        localStorage.removeItem('bobaBlissOrderHistory');
        localStorage.removeItem('orderHistoryClearedAt');
        setOrderHistory([]);
      }
    };

    // Listen for custom event (same tab)
    const handleHistoryCleared = () => {
      console.log('ðŸ“¢ Custom event: orderHistoryCleared, removing all localStorage');
      localStorage.removeItem('bobaBlissOrderHistory');
      localStorage.removeItem('orderHistoryClearedAt');
      setOrderHistory([]);
    };

    window.addEventListener('storage', handleStorageChange);
    window.addEventListener('orderHistoryCleared', handleHistoryCleared as EventListener);

    return () => {
      window.removeEventListener('storage', handleStorageChange);
      window.removeEventListener('orderHistoryCleared', handleHistoryCleared as EventListener);
    };
  }, []);

  // Listen for post-login navigation events (dispatched by LoginPage)
  useEffect(() => {
    const handler = (e: Event) => {
      try {
        const detail = (e as CustomEvent).detail;
        if (detail && detail.view) {
          // show a small success toast, then navigate after a short delay for smoother UX
          if (postLoginTimers.current.nav) {
            clearTimeout(postLoginTimers.current.nav);
          }
          if (postLoginTimers.current.clear) {
            clearTimeout(postLoginTimers.current.clear);
          }
          setPostLoginMessage('ÄÄƒng nháº­p thÃ nh cÃ´ng â€” Ä‘ang chuyá»ƒn hÆ°á»›ng...');
          // navigate after 700ms
          postLoginTimers.current.nav = window.setTimeout(() => {
            setView(detail.view || 'ordering');
          }, 700);
          // clear toast after 2200ms
          postLoginTimers.current.clear = window.setTimeout(() => setPostLoginMessage(null), 2200);
        }
      } catch (err) {
        console.error('Failed to handle post-login navigation', err);
      }
    };
    window.addEventListener('katuu:postLogin', handler as EventListener);
    // cancel handler: e.g. user closed modal or clicked back on access denied
    const cancelHandler = () => {
      try { localStorage.removeItem('postLoginView'); } catch (e) {}
      // short animation or toast for cancellation
      setPostLoginMessage('ÄÃ£ huá»·. Quay láº¡i trang chÃ­nh...');
      if (postLoginTimers.current.nav) clearTimeout(postLoginTimers.current.nav);
      if (postLoginTimers.current.clear) clearTimeout(postLoginTimers.current.clear);
      postLoginTimers.current.nav = window.setTimeout(() => setView('ordering'), 350);
      postLoginTimers.current.clear = window.setTimeout(() => setPostLoginMessage(null), 1600);
    };
    window.addEventListener('katuu:cancelProtected', cancelHandler as EventListener);
     return () => {
       window.removeEventListener('katuu:postLogin', handler as EventListener);
       // cleanup cancel listener
       // (note: removing postLogin handler above; remove cancel below for symmetry)
       window.removeEventListener('katuu:cancelProtected', cancelHandler as EventListener);
     };
   }, []);

  // cleanup timers on unmount
  useEffect(() => {
    return () => {
      if (postLoginTimers.current.nav) clearTimeout(postLoginTimers.current.nav);
      if (postLoginTimers.current.clear) clearTimeout(postLoginTimers.current.clear);
    };
  }, []);

  useEffect(() => {
    const handleScroll = () => {
      setIsScrollButtonVisible(window.scrollY > 300);
      setIsHeaderScrolled(window.scrollY > 10);
    };

    window.addEventListener('scroll', handleScroll);

    return () => window.removeEventListener('scroll', handleScroll);
  }, []);
  
  const scrollToTop = () => {
    window.scrollTo({
      top: 0,
      behavior: 'smooth'
    });
  };

  const handleProductSelect = useCallback((product: Product) => {
    setOrder({
      ...initialOrderState,
      product: product,
      size: sizes[0],
      sugar: SUGAR_LEVELS[0],
      ice: ICE_LEVELS[0],
    });
    setIsReordering(false);
  }, [sizes]);

  const handleResetOrder = useCallback(() => {
    setIsResetting(true);
    scrollToTop();

    setTimeout(() => {
        setOrder({
          ...initialOrderState,
          size: sizes[0],
        });
        // Reset all filters
        setProductCategory('all');
        setHistorySearchTerm('');
        setHistoryCategory('all');
        setIsResetting(false);
        setIsReordering(false);
    }, 300);
  }, [sizes]);

  const handleAddToHistory = useCallback((order: Order, totalPrice: number) => {
    const newHistoricOrder: HistoricOrder = {
        ...order,
        id: Date.now(),
        date: new Date().toISOString(),
        totalPrice,
    };
    setOrderHistory(prevHistory => {
        const updatedHistory = [newHistoricOrder, ...prevHistory];
        try {
            localStorage.setItem('bobaBlissOrderHistory', JSON.stringify(updatedHistory));
        } catch (error) {
            console.error("Failed to save order history to localStorage", error);
        }
        return updatedHistory;
    });
  }, []);
  
  const handleReorder = useCallback((historicOrder: HistoricOrder) => {
    // Deep copy to ensure the historic order is not mutated by reference.
    const deepCopiedOrder = JSON.parse(JSON.stringify(historicOrder));
    const { id, date, totalPrice, ...orderToRestore } = deepCopiedOrder;
    setOrder(orderToRestore);
    setIsReordering(true);
    setView('ordering');
    scrollToTop();

    // Delete the re-ordered item from history
    setOrderHistory(prevHistory => {
      const updatedHistory = prevHistory.filter(order => order.id !== historicOrder.id);
      try {
        localStorage.setItem('bobaBlissOrderHistory', JSON.stringify(updatedHistory));
      } catch (error) {
        console.error("Failed to update order history in localStorage", error);
      }
      return updatedHistory;
    });
  }, []);

  const handleDeleteOrder = useCallback((orderId: number) => {
    setOrderHistory(prevHistory => {
      const updatedHistory = prevHistory.filter(order => order.id !== orderId);
      try {
        localStorage.setItem('bobaBlissOrderHistory', JSON.stringify(updatedHistory));
      } catch (error) {
        console.error("Failed to update order history in localStorage", error);
      }
      return updatedHistory;
    });
  }, []);

  const handleClearHistory = useCallback(() => {
    setOrderHistory([]);
    try {
      localStorage.removeItem('bobaBlissOrderHistory');
    } catch (error) {
      console.error("Failed to clear order history from localStorage", error);
    }
  }, []);

  useEffect(() => {
    if (order.product && customizationRef.current) {
      customizationRef.current.scrollIntoView({
        behavior: 'smooth',
        block: 'start',
      });
    }
  }, [order.product]);

  const handleToppingChange = (topping: Topping) => {
    setOrder((prevOrder) => {
      const isSelected = prevOrder.toppings.some((t) => t.id === topping.id);
      const newToppings = isSelected
        ? prevOrder.toppings.filter((t) => t.id !== topping.id)
        : [...prevOrder.toppings, topping];
      return { ...prevOrder, toppings: newToppings };
    });
  };

  const handleSizeChange = (size: Size) => {
    setOrder((prevOrder) => ({ ...prevOrder, size }));
  };

  const handleSugarChange = (sugar: string) => {
    setOrder((prevOrder) => ({ ...prevOrder, sugar }));
  };

  const handleIceChange = (ice: string) => {
    setOrder((prevOrder) => ({ ...prevOrder, ice }));
  };
  
  const handleNameChange = (name: string) => {
     setOrder((prevOrder) => ({ ...prevOrder, customerName: name }));
  };
  
  const totalPrice = useMemo(() => {
    if (!order.product) return 0;
    const productPrice = order.product.price;
    const toppingsPrice = order.toppings.reduce((sum, topping) => sum + topping.price, 0);
    const sizePrice = order.size?.priceModifier || 0;
    return productPrice + toppingsPrice + sizePrice;
  }, [order]);

  // Guarded navigation helper (sync check using auth token stored in localStorage)
  const guardedSetView = (target: 'ordering' | 'history' | 'admin' | 'dashboard' | 'pending' | 'merged' | 'summary', options?: { requireAdmin?: boolean; requireStaff?: boolean }) => {
    const token = typeof window !== 'undefined' ? localStorage.getItem('authToken') : null;
    if (!token) {
      try { localStorage.setItem('postLoginView', target); } catch (e) {}
      // Open login modal via existing event used elsewhere
      window.dispatchEvent(new CustomEvent('katuu:openLogin'));
      setPostLoginMessage('Báº¡n cáº§n Ä‘Äƒng nháº­p Ä‘á»ƒ tiáº¿p tá»¥c');
      if (postLoginTimers.current?.clear) clearTimeout(postLoginTimers.current.clear);
      postLoginTimers.current = postLoginTimers.current || {};
      postLoginTimers.current.clear = window.setTimeout(() => setPostLoginMessage(null), 2000);
      return;
    }

    try {
      const parts = atob(token).split(':');
      const role = parts[1];
      if (options?.requireAdmin && role !== 'admin') {
        setPostLoginMessage('Chá»‰ Admin má»›i cÃ³ quyá»n truy cáº­p');
        setTimeout(() => setPostLoginMessage(null), 2000);
        return;
      }
      if (options?.requireStaff && !(role === 'staff' || role === 'admin')) {
        setPostLoginMessage('Chá»‰ Staff/Admin má»›i cÃ³ quyá»n truy cáº­p');
        setTimeout(() => setPostLoginMessage(null), 2000);
        return;
      }
      setView(target);
    } catch (e) {
      // if token malformed, fallback to open login
      try { localStorage.setItem('postLoginView', target); } catch (err) {}
      window.dispatchEvent(new CustomEvent('katuu:openLogin'));
    }
  };

  return (
    <AuthProvider>
      <AuditProvider>
        <OrderSessionProvider>
          <div className="min-h-screen font-sans text-stone-800">
            <Header
              onViewHistory={() => setView('history')}
              onViewAdmin={() => guardedSetView('admin', { requireAdmin: true })}
              onViewDashboard={() => guardedSetView('dashboard', { requireStaff: true })}
              onViewPending={() => guardedSetView('pending', { requireStaff: true })}
              onViewMerged={() => guardedSetView('merged', { requireStaff: true })}
              onViewSummary={() => guardedSetView('summary', { requireStaff: true })}
              historyCount={orderHistory.length}
              isScrolled={isHeaderScrolled}
            />

            {/* Post-login toast */}
            {postLoginMessage && (
              <div className="fixed top-20 right-4 z-50 bg-emerald-600 text-white px-6 py-3 rounded-lg shadow-lg animate-fade-in-pop">
                {postLoginMessage}
              </div>
            )}

            {view === 'ordering' ? (
              <main className="container mx-auto px-4 py-8 max-w-6xl">
                <div className="grid grid-cols-1 lg:grid-cols-3 lg:gap-8">
                  <div className="lg:col-span-2">
                    <ProductSelection
                      products={products}
                      onProductSelect={handleProductSelect}
                      selectedProductId={order.product?.id}
                      selectedCategory={productCategory}
                      onCategoryChange={setProductCategory}
                      isLoading={isLoadingProducts}
                    />
                    {order.product && (
                      <div ref={customizationRef} className="mt-12">
                        <CustomizationOptions
                          order={order}
                          toppings={toppings}
                          sizes={sizes}
                          onToppingChange={handleToppingChange}
                          onSizeChange={handleSizeChange}
                          onSugarChange={handleSugarChange}
                          onIceChange={handleIceChange}
                        />
                      </div>
                    )}
                  </div>
                  <div className="lg:col-span-1 mt-12 lg:mt-0">
                    <OrderSummary
                      order={order}
                      totalPrice={totalPrice}
                      onNameChange={handleNameChange}
                      onResetOrder={handleResetOrder}
                      isResetting={isResetting}
                      isReordering={isReordering}
                      onAddToHistory={handleAddToHistory}
                      onClearHistory={handleClearHistory}
                    />
                  </div>
                </div>
              </main>
            ) : view === 'pending' ? (
              <ProtectedRoute desiredView="pending">
                <PendingOrdersPanel />
              </ProtectedRoute>
            ) : view === 'merged' ? (
              <ProtectedRoute desiredView="merged">
                <MergedOrdersHistory />
              </ProtectedRoute>
            ) : view === 'summary' ? (
              <ProtectedRoute desiredView="summary">
                <OrderSummaryReport onBack={() => setView('ordering')} />
              </ProtectedRoute>
            ) : view === 'dashboard' ? (
              <ProtectedRoute desiredView="dashboard">
                <Dashboard
                  orderHistory={orderHistory}
                  products={products}
                  categories={categories}
                  onBack={() => setView('ordering')}
                />
              </ProtectedRoute>
            ) : view === 'admin' ? (
              <ProtectedRoute requireAdmin desiredView="admin">
                <AdminPanel
                  products={products}
                  toppings={toppings}
                  sizes={sizes}
                  categories={categories}
                  onUpdateProducts={handleUpdateProducts}
                  onUpdateToppings={handleUpdateToppings}
                  onUpdateSizes={handleUpdateSizes}
                  onUpdateCategories={handleUpdateCategories}
                  onBack={() => setView('ordering')}
                />
              </ProtectedRoute>
            ) : (
              <OrderHistory
                onBack={() => setView('ordering')}
                history={orderHistory}
                onReorder={handleReorder}
                onDeleteOrder={handleDeleteOrder}
                searchTerm={historySearchTerm}
                onSearchTermChange={setHistorySearchTerm}
                selectedCategory={historyCategory}
                onCategoryChange={setHistoryCategory}
                isLoading={isLoadingHistory}
            />
          )}

          {view === 'ordering' && (
            <button
              onClick={scrollToTop}
              className={`fixed bottom-6 right-6 z-20 p-3 bg-amber-600 text-white rounded-full shadow-lg hover:bg-amber-700 transition-all duration-300 transform hover:-translate-y-1 active:scale-95 ${
                isScrollButtonVisible
                  ? 'opacity-100 translate-y-0 pointer-events-auto'
                  : 'opacity-0 translate-y-4 pointer-events-none'
              }`}
              aria-label="Scroll to top"
            >
              <ArrowUpIcon className="w-6 h-6" />
            </button>
          )}
        </div>
      </OrderSessionProvider>
    </AuditProvider>
  </AuthProvider>
);
};

export default App;
